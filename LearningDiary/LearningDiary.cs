using System;
using System.Collections.Generic;

namespace LearningDiary
{
    class LearningDiary
    {
<<<<<<< HEAD
        //Yritetty tehdä siten, että ohjelmaa voisi laajentaa tulevina viikkoina modulaarisesti -> katsotaan onnistuuko
        //UI:n toteutus hieman rajoittunut C# kirjaston rajoittuneisuuden takia. Tarvitsisi jonkun paremman framwork ncurses tjs.p
        //Tukee kaikkien topicien "kannasta" sekä uusien topicien kirjoituksen "kantaan"
        //Updatejen tekeminen TODO listalla. Onnistuu helpommin oikealla tietokannalla

        private Dictionary<int, Topic> PastLearnings;
        private Dictionary<int, Task> TasksWithoutTopic;
        private HashSet<int> TaskIdList;
        private FileIO PersistentStorageTopics;
        private FileIO PersistentStorageTasks;

        public LearningDiary(FileIO PersistentStorageTopics, FileIO PersistentStorageTasks)
=======
        //SQL tyylinen jako eri "tauluihin", taskit ja topicit taskit pitää parittaa erikseen -> hidasta jos iso määrä
        private Dictionary<int, Topic> PastLearnings;
        private Dictionary<int, Task> TasksWithoutTopic;
        private HashSet<int> TaskIdList;
        //Voisi olla Storage interface, voisi käyttää plugin tyyppisesti eri datalähteitä
        private object StorageDevice;
        public LearningDiary(object StorageDevice)
>>>>>>> main
        {
            this.PastLearnings = new Dictionary<int, Topic>();
            this.TasksWithoutTopic = new Dictionary<int, Task>();
            this.TaskIdList = new HashSet<int>();
<<<<<<< HEAD
            this.PersistentStorageTopics = PersistentStorageTopics;
            this.PersistentStorageTasks = PersistentStorageTasks;
            LoadAllTopicsFromStorage();
            //LoadAllTasksFromStorage();
=======
>>>>>>> main
        }

        public LearningDiary()
        {
            this.PastLearnings = new Dictionary<int, Topic>();
            this.TasksWithoutTopic = new Dictionary<int, Task>();
            this.TaskIdList = new HashSet<int>();
        }

        private void LoadAllTopicsFromStorage()
        {
<<<<<<< HEAD
            List<Dictionary<string,string>> allTopics = this.PersistentStorageTopics.GetAll();

            foreach (Dictionary<string,string> topicParameters in allTopics)
            {

                int topicId = Convert.ToInt32(topicParameters["id"]);
                if (this.PastLearnings.ContainsKey(topicId))
                {
                    throw new ArgumentException($"Unique constrain violation, topicId = {topicId} not unique");
                }

                else
                {
                    try
                    {
                        Topic newTopic = new Topic()
                        {
                            id = topicId,
                            Title = topicParameters["Title"],
                            Description = topicParameters["Description"],
                            EstimatedTimeToMaster = Convert.ToDouble(topicParameters["EstimatedTimeToMaster"]),
                            Source = topicParameters["Source"],
                            StartLearningDate = Convert.ToDateTime(topicParameters["StartLearningDate"]),
                            InProgress = Convert.ToBoolean(topicParameters["InProgress"]),
                            CompletionDate = Convert.ToDateTime(topicParameters["CompletionDate"]),
                            AlreadyStudied = Convert.ToBoolean(topicParameters["AlreadyStudied"]),
                            TasksRelatedToTopic = new List<Task>()
                    };
                        this.PastLearnings.Add(topicId, newTopic);
                    }
                    catch (Exception e)
                    {

                        Console.WriteLine(e);
                    }
                }
            }
        }

        //overloading vai oma metodi AddTopicToDiaryWithAutoGeneratedId?
        //autogenerate taskID
        public void AddTopicToDiary(string title, string description, double estimatedTimeToMaster, string source)
        {
            //Unique ID generointi kannan vastuulle?
            int topicId = PastLearnings.Count+1;

            AddTopicToDiary(topicId, title, description, estimatedTimeToMaster, source);

        }

        public void AddTopicToDiary(int topicId, string title, string description, double estimatedTimeToMaster, string source)
        {

            if (this.PastLearnings.ContainsKey(topicId))
            {
                throw new ArgumentException($"Unique constrain violation, topicId = {topicId} not unique");
            }

            else
            {
                Topic newTopic = new Topic(topicId, title, description, estimatedTimeToMaster, source);
                this.PastLearnings.Add(topicId, newTopic);
                this.PersistentStorageTopics.Insert(newTopic);
            }

        }

        public void StartTopicById(int topicId)
        {
            if (this.PastLearnings.ContainsKey(topicId))
            {
                this.PastLearnings[topicId].StartLearning();
=======
        }

        private void SaveAllTopicsToStorage()
        {
        }

        //overloading vai oma metodi AddTopicToDiaryWithAutoGeneratedId?
        //autogenerate taskID
        public void AddTopicToDiary(string title, string description, double estimatedTimeToMaster, string source)
        {
            //Who keeps track of the ID generation, get Unique Id from storage device, ?
            int topicId = PastLearnings.Count;

            AddTopicToDiary(topicId, title, description, estimatedTimeToMaster, source);

        }

        public void AddTopicToDiary(int topicId, string title, string description, double estimatedTimeToMaster, string source)
        {
            //toistoa?
            if (this.PastLearnings.ContainsKey(topicId))
            {
                throw new ArgumentException($"Unique constrain violation, topicId = {topicId} not unique");
>>>>>>> main
            }

            else
            {
<<<<<<< HEAD
                throw new ArgumentException($"Task ID not found, Topicid = {topicId}");
            }
        }

        public void FinishTopicById(int topicId)
        {
            if (this.PastLearnings.ContainsKey(topicId))
            {
                this.PastLearnings[topicId].FinishLearning();
            }
            else
            {

                throw new ArgumentException($"Topic ID not found, Topicid = {topicId}");
            }
        }

        public Topic GetTopicById(int topicId)
        {
            if (this.PastLearnings.ContainsKey(topicId))
            {
                return this.PastLearnings[topicId];
            }
=======
                Topic newTopic = new Topic(topicId, title, description, estimatedTimeToMaster, source);
                this.PastLearnings.Add(topicId, newTopic);
            }

        }

        //autogenerate taskID
        public void AddTaskToTopic(int topicId, string title, string description, string notes, DateTime deadline)
        {
            int taskId = this.TaskIdList.Count;
            AddTaskToTopic(taskId, topicId, title, description, notes, deadline);
        }


        public void AddTaskToTopic(int taskId, int topicId, string title, string description, string notes, DateTime deadline)
        {
            //toistoa?
            if (this.TaskIdList.Contains(taskId))
            {
                throw new ArgumentException($"Unique constrain violation, TaskId = {taskId} not unique");
            }

            else
            {
                Task newTask = new Task(taskId, topicId, title, description, notes, deadline);
                this.PastLearnings[topicId].TasksRelatedToTopic.Add(newTask);
                this.TaskIdList.Add(taskId);
            }
        }

        //autogenerate taskID
        public void AddTaskWithoutTopic(string title, string description, string notes, DateTime deadline)
        {
            int taskId = this.TaskIdList.Count;
            AddTaskWithoutTopic(taskId, title, description, notes, deadline);
        }

        public void AddTaskWithoutTopic(int taskId, string title, string description, string notes, DateTime deadline)
        {
            if (this.TaskIdList.Contains(taskId))
            {
                throw new ArgumentException($"Unique constrain violation, TaskId = {taskId} not unique");
            }

            else
            {
                Task newTask = new Task(taskId, title, description, notes, deadline);
                this.TasksWithoutTopic.Add(taskId, newTask);
                this.TaskIdList.Add(taskId);
            }
        }

        public void StartTopicById(int topicId)
        {
            if (this.PastLearnings.ContainsKey(topicId))
            {
                this.PastLearnings[topicId].StartLearning();
            }
            throw new ArgumentException($"Task ID not found, Topicid = {topicId}");
        }

        public void FinishTopicById(int topicId)
        {
            if (this.PastLearnings.ContainsKey(topicId))
            {
                this.PastLearnings[topicId].FinishLearning();
            }
            throw new ArgumentException($"Topic ID not found, Topicid = {topicId}");
        }

        public void FinishTaskById(int taskId)
        {
            if (this.TasksWithoutTopic.ContainsKey(taskId))
            {
                this.TasksWithoutTopic[taskId].FinishTask();
            }
            throw new ArgumentException($"Task ID not found, taskid = {taskId}");
        }


        public List<Topic> GetAllTopics()
        {
            return new List<Topic>(this.PastLearnings.Values);
        }

        public List<Task> GetAllTasksRelatedToTopic(int topicId)
        {
            return this.PastLearnings[topicId].TasksRelatedToTopic;
        }
>>>>>>> main

            else
            {
                throw new ArgumentException($"Topic ID not found, Topicid = {topicId}");
            }
        }
        public List<Topic> GetAllTopics()
        {
            return new List<Topic>(this.PastLearnings.Values);
        }



<<<<<<< HEAD
        //autogenerate taskID
        public void AddTaskToTopic(int topicId, string title, string description, string notes, DateTime deadline)
=======


        public List<Topic> GetAllItems()
>>>>>>> main
        {
            int taskId = this.TaskIdList.Count;
            AddTaskToTopic(taskId, topicId, title, description, notes, deadline);
        }


        public void AddTaskToTopic(int taskId, int topicId, string title, string description, string notes, DateTime deadline)
        {
            if (this.TaskIdList.Contains(taskId))
            {
                throw new ArgumentException($"Unique constrain violation, TaskId = {taskId} not unique");
            }

            else if (this.PastLearnings.ContainsKey(topicId))
            {
                Task newTask = new Task(taskId, topicId, title, description, notes, deadline);
                this.PastLearnings[topicId].TasksRelatedToTopic.Add(newTask);
                this.TaskIdList.Add(taskId);
                this.PersistentStorageTasks.Insert(newTask);
            }
            else
            {
                throw new ArgumentException($"TopickId = {topicId} not found");
            }
        }

        //autogenerate taskID
        public void AddTaskWithoutTopic(string title, string description, string notes, DateTime deadline)
        {
            int taskId = this.TaskIdList.Count;
            AddTaskWithoutTopic(taskId, title, description, notes, deadline);
        }

        public void AddTaskWithoutTopic(int taskId, string title, string description, string notes, DateTime deadline)
        {
            if (!this.TaskIdList.Contains(taskId))
            {
                throw new ArgumentException($"Unique constrain violation, TaskId = {taskId} not unique");
            }

            else
            {
                Task newTask = new Task(taskId, title, description, notes, deadline);
                this.TasksWithoutTopic.Add(taskId, newTask);
                this.TaskIdList.Add(taskId);
            }
        }

        public void FinishTaskById(int taskId)
        {
            if (this.TasksWithoutTopic.ContainsKey(taskId))
            {
                this.TasksWithoutTopic[taskId].FinishTask();
            }
            else
            {
                throw new ArgumentException($"Task ID not found, taskid = {taskId}");

            }
        }

        public List<Task> GetAllTasksRelatedToTopic(int topicId)
        {
            return this.PastLearnings[topicId].TasksRelatedToTopic;
        }
    }
}
